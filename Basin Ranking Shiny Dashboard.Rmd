---
title: "Untitled"
author: "J.Hart"
date: "2025-11-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(shiny)
library(shinydashboard)
library(sf)
library(leaflet)
library(classInt)
library(dplyr)

ui <- dashboardPage(
  dashboardHeader(title = "SAP Watershed Ranking Dashboard",
                  titleWidth = 450),
  dashboardSidebar(
    sidebarMenu(
      menuItem("Map and Table", tabName = "maptable", icon = icon("map"),
               selected = TRUE)
    ),
    fileInput("csvfile", "Upload CSV File", accept = ".csv"),
    fileInput("shpzip", "Upload Zipped Shapefile (.zip)", accept = ".zip"),
    uiOutput("multiplier_inputs"),
    hr(),
    uiOutput("break_sliders_ui"),
    hr(),
    downloadButton("downloadData", "Download Ranked Results CSV",
                   style = "color: white; 
                   background-color: #007BFF;
                   border-color: #007BFF; 
                   font-weight: bold;
                   font-size: 14px;")
  ),
  dashboardBody(
    tabItems(
      tabItem(tabName = "maptable",
              fluidRow(
                box(width = 12, leafletOutput("map", height = 600))
              ),
              fluidRow(
                box(width = 12, tableOutput("ranked_table"))
              )
      )
    )
  )
)


server <- function(input, output, session) {
  
  data <- reactive({
    req(input$csvfile)
    read.csv(input$csvfile$datapath, check.names = FALSE, stringsAsFactors = FALSE)
  })
  
  numeric_cols <- reactive({
    df <- data()
    num_cols <- names(df)[sapply(df, is.numeric)]
    setdiff(num_cols, names(df)[1])
  })
  
  # Dynamic numeric inputs for multipliers shown in sidebar
  output$multiplier_inputs <- renderUI({
    req(numeric_cols())
    lapply(numeric_cols(), function(col) {
      numericInput(
        inputId = paste0("mult_", col),
        label = paste("Multiplier for", col),
        value = 1,
        min = 0
      )
    })
  })
  
  shapefile <- reactive({
    req(input$shpzip)
    temp_dir <- tempdir()
    unzip(input$shpzip$datapath, exdir = temp_dir)
    shp_path <- list.files(temp_dir, pattern = "\\.shp$", full.names = TRUE)
    if (length(shp_path) == 0) {
      stop("No shapefile (.shp) found in the uploaded zip")
    }
    sf::st_read(shp_path[1], quiet = TRUE)
  })
  
  ranked_data <- reactive({
    df <- data()
    cols <- numeric_cols()
    req(cols)
    weighted_df <- df[, c(names(df)[1], cols), drop = FALSE]
    for (col in cols) {
      multiplier <- input[[paste0("mult_", col)]]
      # Default multiplier to 1 if blank or NULL
      if (is.null(multiplier) || is.na(multiplier) || multiplier == "") {
        multiplier <- 1
      }
      weighted_df[[col]] <- weighted_df[[col]] * multiplier
    }
    weighted_df$`Total Score` <- rowSums(weighted_df[, cols], na.rm = TRUE)
    weighted_df %>% 
      arrange(desc(`Total Score`)) %>%
      mutate(Rank = row_number()) 
  })
  
  default_breaks <- reactive({
    scores <- ranked_data()[["Total Score"]]
    if (length(scores) == 0) return(NULL)
    quantile(scores, probs = c(0, 1/3, 2/3, 1), na.rm = TRUE)
  })
  
  output$break_sliders_ui <- renderUI({
    req(default_breaks())
    breaks <- default_breaks()
    tagList(
      sliderInput("break1", "Low-Medium Break:",
                  min = floor(breaks[1]),
                  max = ceiling(breaks[4]),
                  value = breaks[2], step = 0.1),
      sliderInput("break2", "Medium-High Break:",
                  min = floor(breaks[1]),
                  max = ceiling(breaks[4]),
                  value = breaks[3], step = 0.1)
    )
  })
  
  pal <- reactive({
    req(input$break1, input$break2)
    bins <- sort(c(-Inf, input$break1, input$break2, Inf))
    colorBin(
      palette = c("red", "yellow", "olivedrab3"),
      domain = ranked_data()$`Total Score`,
      bins = bins,
      na.color = "transparent"
    )
  })
  
  joined_sf <- reactive({
    req(shapefile(), ranked_data())
    shp <- shapefile()
    rankdf <- ranked_data()
    if (!("Basin" %in% names(shp))) {
      stop("Shapefile must contain a 'Basin' column matching CSV first column")
    }
    shp %>%
      left_join(rankdf, by = setNames(names(rankdf)[1], "Basin"))
  })
  
  output$map <- renderLeaflet({
    shp <- joined_sf()
    req(shp)
    pal_func <- pal()
    
    leaflet(shp) %>%
      addProviderTiles("CartoDB.Positron") %>%
      addPolygons(
        fillColor = ~pal_func(`Total Score`),
        weight = 2,
        opacity = 1,
        color = "black",
        dashArray = "3",
        fillOpacity = 0.7,
        highlight = highlightOptions(
          weight = 3,
          color = "#666",
          dashArray = "",
          fillOpacity = 0.5,
          bringToFront = TRUE),
        label = ~paste0(Basin, ": ", round(`Total Score`, 2))
      ) %>%
      addLabelOnlyMarkers(
        data = shp,
        lng = ~st_coordinates(st_centroid(geometry))[,1],
        lat = ~st_coordinates(st_centroid(geometry))[,2],
        label = ~Basin,
        labelOptions = labelOptions(noHide = TRUE, direction = "center",
                                    textOnly = TRUE, style = list(
                                      "font-weight" = "bold",
                                      "color" = "black",
                                      "font-size" = "12px",
                                      "text-shadow" = "1px 1px 2px white"
                                    ))
      ) %>%
      addLegend(
        colors = c("green", "yellow", "red"),
       labels = c("High", "Medium", "Low"),
        title = "Total Score",
        position = "bottomright")
  })
  
  output$ranked_table <- renderTable({
    ranked_data()
  })
  
  output$downloadData <- downloadHandler(
    filename = function() {
      paste("ranked_results_", Sys.Date(), ".csv", sep = "")
    },
    content = function(file) {
      write.csv(ranked_data(), file, row.names = FALSE)
    }
  )
}

shinyApp(ui, server)


```

